
-- interesting: pack(...) unrolls into outer âˆƒ type, _ unrolls into inner âˆƒ type
alg listlen = (injâ‚ () â‡’ 0 â€– injâ‚‚ (_, (p, ())) â‡’ (p + 1))
type list(l : â„•) = Î¼(I âŠ• ([âˆƒj : â„• . nat(j)] âŠ— (Id âŠ— I))) âŠƒ listlen â‡’ l

let list_nil = (return into(injâ‚ <>) : â†‘list(0))
def list_cons : âˆ€l : â„• . âˆ€i : â„• . (nat(i) â†’ (list(l) â†’ â†‘list((l + 1))))
              = Î»x . Î»xs . return into(injâ‚‚ <x, <xs, <>>>)

def list_head : âˆ€l : â„• . [(l â‰¥ 1)] âŠƒ (list(l) â†’ â†‘âˆƒi : â„• . nat(i))
              = Î»l . match l { into(ll) â‡’ match ll {
                  injâ‚ u â‡’ unreachable
                â€– injâ‚‚ p â‡’ match p { <x, xs> â‡’ return x }
                }}

def list_tail : âˆ€l : â„• . [(l â‰¥ 1)] âŠƒ (list(l) â†’ â†‘list((l - 1)))
              = Î»l . match l { into(ll) â‡’ match ll {
                  injâ‚ u â‡’ unreachable
                â€– injâ‚‚ p â‡’ match p { <x, xsu> â‡’ match xsu { <xs, u> â‡’ return xs }}
                }}

rec list_idx : âˆ€l : â„• . âˆ€i : â„• . [(i < l)] âŠƒ (list(l) â†’ (nat(i) â†’ â†‘âˆƒj : â„• . nat(j)))
             = Î»l . Î»idx . match idx { into(ii) â‡’ match ii {
                 injâ‚ u â‡’
                   let head = list_head(l);
                   return head
               â€– injâ‚‚ pair â‡’ match pair { <idx_pred, u> â‡’
                   let tail = list_tail(l);
                   let result = list_idx(tail, idx_pred);
                   return result
               }}}

rec list_len : âˆ€l : â„• . (list(l) â†’ â†‘nat(l))
             = Î»l . match l { into(ll) â‡’ match ll {
                 injâ‚ u â‡’ return nat_0
               â€– injâ‚‚ p â‡’
                   let tail = list_tail(l);
                   let tail_len = list_len(tail);
                   let result = nat_succ(tail_len);
                   return result
               }}

rec list_split : âˆ€l : â„• . âˆ€i : â„• . [(i â‰¤ l)] âŠƒ (list(l) â†’ (nat(i) â†’ â†‘(list(i) Ã— list((l - i)))))
               = Î»l . Î»i .
                 let done = nat_le(i, nat_0);
                 match done {
                   injâ‚‚ t â‡’ return <list_nil, l>
                 â€– injâ‚ f â‡’
                     let i_pred = nat_pred(i);
                     let head = list_head(l);
                     let tail = list_tail(l);
                     let rest = list_split(tail, i_pred);
                     match rest {
                       <left_rest, right_result> â‡’
                         let left_result = list_cons(head, left_rest);
                         return <left_result, right_result>
                     }
                 }

rec list_append : âˆ€a : â„• . âˆ€b : â„• . (list(a) â†’ (list(b) â†’ â†‘list((a + b))))
                = Î»left . Î»right .
                  match left { into(left_) â‡’ match left_ {
                    injâ‚ nil â‡’ return right
                  â€– injâ‚‚ cons â‡’ match cons {
                      <head, rest> â‡’ match rest {
                        <tail, u> â‡’
                          let result_tail = list_append(tail, right);
                          return into(injâ‚‚ <head, <result_tail, <>>>)
                }}}}

alg slist = (injâ‚ () â‡’ (0, (0, T)) â€– injâ‚‚ (pack(j, _), (t, ())) â‡’ (j, ((Ï€â‚ Ï€â‚‚ t + 1), ((Ï€â‚‚ Ï€â‚‚ t = T) âˆ§ (Ï€â‚ t â‰¤ j)))))
type slist(i : (â„• Ã— (â„• Ã— ğ”¹))) = Î¼(I âŠ• ([âˆƒj : â„• . nat(j)] âŠ— (Id âŠ— I))) âŠƒ slist â‡’ i

def mergesort_split : âˆ€l : â„• . [(l â‰¥ 2)] âŠƒ (list(l) â†’ â†‘(list((l / 2)) Ã— list(((l + 1) / 2))))
                    = Î»l .
                      let len = list_len(l);
                      let half = nat_div(len, nat_2);
                      let result = list_split(l, half);
                      return result

rec mergesort_merge : âˆ€total : â„• . âˆ€left : (â„• Ã— (â„• Ã— ğ”¹)) . âˆ€right : (â„• Ã— (â„• Ã— ğ”¹))
                    . [((Ï€â‚ Ï€â‚‚ left â‰¤ total) âˆ§ ((Ï€â‚ Ï€â‚‚ left + Ï€â‚ Ï€â‚‚ right) = total))]
                    âŠƒ [((Ï€â‚‚ Ï€â‚‚ left = T) âˆ§ (Ï€â‚‚ Ï€â‚‚ right = T))]
                    âŠƒ (nat(total) â†’ (slist(left) â†’ (slist(right) â†’ â†‘slist((((Ï€â‚ left - Ï€â‚ right) + Ï€â‚ right), (total, T))))))
                    = Î»total . Î»left . Î»right .
                      match left { into(left_) â‡’ match left_ {
                        injâ‚ nil â‡’ return right
                      â€– injâ‚‚ left_cons â‡’ match right { into(right_) â‡’ match right_ {
                          injâ‚ nil â‡’ return left
                        â€– injâ‚‚ right_cons â‡’ match left_cons {
                            <left_head, left_rest> â‡’ match right_cons {
                              <right_head, right_rest> â‡’
                                let rest_count = nat_pred(total);
                                let left_ge = nat_ge(left_head, right_head);
                                match left_ge {
                                  injâ‚‚ t â‡’ match left_rest {
                                    <left_tail, u> â‡’
                                      let rest = mergesort_merge(rest_count, left_tail, right);
                                      return into(injâ‚‚ <left_head, <rest, <>>>)
                                  }
                                â€– injâ‚ f â‡’ match right_rest {
                                    <right_tail, u> â‡’
                                      let rest = mergesort_merge(rest_count, left, right_tail);
                                      return into(injâ‚‚ <right_head, <rest, <>>>)
                    }}}}}}}}

rec mergesort : âˆ€l : â„• . (list(l) â†’ â†‘âˆƒi : (â„• Ã— (â„• Ã— ğ”¹)) . (slist(i) âˆ§ [((Ï€â‚ Ï€â‚‚ i = l) âˆ§ (Ï€â‚‚ Ï€â‚‚ i = T))]))
              = Î»lst .
                let len = list_len(lst);
                let simple = nat_le(len, nat_1);
                match simple {
                  injâ‚‚ t â‡’ match lst { into(lst_) â‡’ match lst_ {
                    injâ‚ u â‡’ return into(injâ‚ <>)
                  â€– injâ‚‚ lst__ â‡’ match lst__ { <x, xs> â‡’ return into(injâ‚‚ <x, <into(injâ‚ <>), <>>>) }
                  }}
                â€– injâ‚ f â‡’
                    let parts = mergesort_split(lst);
                    match parts {
                      <left, right> â‡’
                        let left_sorted = mergesort(left);
                        let right_sorted = mergesort(right);
                        let sorted = mergesort_merge(len, left_sorted, right_sorted);
                        return sorted
                }}

rec quicksort_split : âˆ€l : â„• . âˆ€f : â„• . (nat(f) â†’ (list(l) â†’ â†‘âˆƒs : â„• . ((list(s) Ã— list((l - s))) âˆ§ [(s â‰¤ l)])))
                    = Î»pivot . Î»lst .
                      match lst { into(lst_) â‡’ match lst_ {
                        injâ‚ nil â‡’ return <list_nil, list_nil>
                      â€– injâ‚‚ cons â‡’ match cons { <head, rest> â‡’ match rest { <tail, u> â‡’
                          let tail_split = quicksort_split(pivot, tail);
                          match tail_split { <le, gt> â‡’
                            let is_le = nat_le(head, pivot);
                            match is_le {
                              injâ‚ f â‡’ return <le, into(injâ‚‚ <head, <gt, <>>>)>
                            â€– injâ‚‚ t â‡’ return <into(injâ‚‚ <head, <le, <>>>), gt>
                      }}}}}}

rec quicksort : âˆ€l : â„• . (list(l) â†’ â†‘list(l))
              = Î»lst . match lst { into(lst_) â‡’ match lst_ {
                  injâ‚ nil â‡’ return lst
                â€– injâ‚‚ cons â‡’ match cons {
                    <pivot, rest> â‡’ match rest {
                      <tail, u> â‡’
                        let le_gt = quicksort_split(pivot, tail);
                        match le_gt {
                          <le, gt> â‡’
                            let le_sorted = quicksort(le);
                            let gt_sorted = quicksort(gt);
                            let result = list_append(le_sorted, into(injâ‚‚ <pivot, <gt_sorted, <>>>));
                            return result
                }}}}}

