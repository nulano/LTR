
-- interesting: pack(...) unrolls into outer ∃ type, _ unrolls into inner ∃ type
alg listlen = (inj₁ () ⇒ 0 ‖ inj₂ (_, (p, ())) ⇒ (p + 1))
type list(l : ℕ) = μ(I ⊕ ([∃j : ℕ . nat(j)] ⊗ (Id ⊗ I))) ⊃ listlen ⇒ l

let list_nil = (return into(inj₁ <>) : ↑list(0))
def list_cons : ∀l : ℕ . ∀i : ℕ . (nat(i) → (list(l) → ↑list((l + 1))))
              = λx . λxs . return into(inj₂ <x, <xs, <>>>)

def list_head : ∀l : ℕ . [(l ≥ 1)] ⊃ (list(l) → ↑∃i : ℕ . nat(i))
              = λl . match l { into(ll) ⇒ match ll {
                  inj₁ u ⇒ unreachable
                ‖ inj₂ p ⇒ match p { <x, xs> ⇒ return x }
                }}

def list_tail : ∀l : ℕ . [(l ≥ 1)] ⊃ (list(l) → ↑list((l - 1)))
              = λl . match l { into(ll) ⇒ match ll {
                  inj₁ u ⇒ unreachable
                ‖ inj₂ p ⇒ match p { <x, xsu> ⇒ match xsu { <xs, u> ⇒ return xs }}
                }}

rec list_idx : ∀l : ℕ . ∀i : ℕ . [(i < l)] ⊃ (list(l) → (nat(i) → ↑∃j : ℕ . nat(j)))
             = λl . λidx . match idx { into(ii) ⇒ match ii {
                 inj₁ u ⇒
                   let head = list_head(l);
                   return head
               ‖ inj₂ pair ⇒ match pair { <idx_pred, u> ⇒
                   let tail = list_tail(l);
                   let result = list_idx(tail, idx_pred);
                   return result
               }}}

rec list_len : ∀l : ℕ . (list(l) → ↑nat(l))
             = λl . match l { into(ll) ⇒ match ll {
                 inj₁ u ⇒ return nat_0
               ‖ inj₂ p ⇒
                   let tail = list_tail(l);
                   let tail_len = list_len(tail);
                   let result = nat_succ(tail_len);
                   return result
               }}
