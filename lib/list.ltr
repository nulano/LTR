alg listlen = (injâ‚ () â‡’ 0 â€– injâ‚‚ (_, (p, ())) â‡’ (p + 1))
type list(l : â„•) = Î¼(I âŠ• ([unat] âŠ— (Id âŠ— I))) âŠƒ listlen â‡’ l

let list_nil : list(0) = into(injâ‚ <>)
def list_cons : âˆ€l : â„• . (unat â†’ (list(l) â†’ â†‘list((l + 1))))
              = Î»x . Î»xs . return into(injâ‚‚ <x, <xs, <>>>)

def list_head : âˆ€l : â„• . [(l â‰¥ 1)] âŠƒ (list(l) â†’ â†‘unat)
              = Î»l . match l { into(ll) â‡’ match ll {
                  injâ‚ nil â‡’ unreachable
                â€– injâ‚‚ cons â‡’ match cons { <x, xs> â‡’ return x }
                }}

def list_tail : âˆ€l : â„• . [(l â‰¥ 1)] âŠƒ (list(l) â†’ â†‘list((l - 1)))
              = Î»l . match l { into(ll) â‡’ match ll {
                  injâ‚ nil â‡’ unreachable
                â€– injâ‚‚ cons â‡’ match cons {
                    <x, xsu> â‡’ match xsu { <xs, u> â‡’ return xs }}
                }}

rec list_len : âˆ€l : â„• . (list(l) â†’ â†‘nat(l))
             = Î»l . match l { into(ll) â‡’ match ll {
                 injâ‚ nil â‡’ return nat_0
               â€– injâ‚‚ cons â‡’
                   let tail = list_tail(l);
                   let tail_len = list_len(tail);
                   let result = nat_succ(tail_len);
                   return result
               }}

rec list_idx : âˆ€l : â„• . âˆ€i : â„• . [(i < l)] âŠƒ (list(l) â†’ (nat(i) â†’ â†‘unat))
             = Î»l . Î»idx . match idx { into(ii) â‡’ match ii {
                 injâ‚ zero â‡’
                   let head = list_head(l);
                   return head
               â€– injâ‚‚ succ â‡’ match succ { <idx_pred, u> â‡’
                   let tail = list_tail(l);
                   let result = list_idx(tail, idx_pred);
                   return result
               }}}

rec list_split : âˆ€l : â„• . âˆ€i : â„• . [(i â‰¤ l)] âŠƒ (list(l) â†’ (nat(i) â†’ â†‘(list(i) Ã— list((l - i)))))
               = Î»l . Î»i . match i { into(ii) â‡’ match ii {
                   injâ‚ zero â‡’ return <list_nil, l>
                 â€– injâ‚‚ succ â‡’ match succ { <i_pred, u> â‡’
                     let head = list_head(l);
                     let tail = list_tail(l);
                     let rest = list_split(tail, i_pred);
                     match rest {
                       <left_rest, right_result> â‡’
                         let left_result = list_cons(head, left_rest);
                         return <left_result, right_result>
                     }
                 }}}

rec list_append : âˆ€a : â„• . âˆ€b : â„• . (list(a) â†’ (list(b) â†’ â†‘list((a + b))))
                = Î»left . Î»right .
                  match left { into(left_) â‡’ match left_ {
                    injâ‚ nil â‡’ return right
                  â€– injâ‚‚ cons â‡’ match cons {
                      <head, rest> â‡’ match rest {
                        <tail, u> â‡’
                          let result_tail = list_append(tail, right);
                          return into(injâ‚‚ <head, <result_tail, <>>>)
                }}}}

alg slist = (injâ‚ () â‡’ (0, (0, T)) â€– injâ‚‚ (pack(j, _), (t, ())) â‡’ (j, ((Ï€â‚ Ï€â‚‚ t + 1), ((Ï€â‚‚ Ï€â‚‚ t = T) âˆ§ (Ï€â‚ t â‰¤ j)))))
type slist(i : (â„• Ã— (â„• Ã— ğ”¹))) = Î¼(I âŠ• ([âˆƒj : â„• . nat(j)] âŠ— (Id âŠ— I))) âŠƒ slist â‡’ i

def mergesort_split : âˆ€l : â„• . [(l â‰¥ 2)] âŠƒ (list(l) â†’ â†‘(list((l / 2)) Ã— list(((l + 1) / 2))))
                    = Î»l .
                      let len = list_len(l);
                      let half = nat_div(len, nat_2);
                      let result = list_split(l, half);
                      return result

rec mergesort_merge : âˆ€total : â„• . âˆ€left : (â„• Ã— (â„• Ã— ğ”¹)) . âˆ€right : (â„• Ã— (â„• Ã— ğ”¹))
                    . [((Ï€â‚ Ï€â‚‚ left â‰¤ total) âˆ§ ((Ï€â‚ Ï€â‚‚ left + Ï€â‚ Ï€â‚‚ right) = total))]
                    âŠƒ [((Ï€â‚‚ Ï€â‚‚ left = T) âˆ§ (Ï€â‚‚ Ï€â‚‚ right = T))]
                    âŠƒ (nat(total) â†’ (slist(left) â†’ (slist(right) â†’ â†‘slist((((Ï€â‚ left - Ï€â‚ right) + Ï€â‚ right), (total, T))))))
                    = Î»total . Î»left . Î»right .
                      match left { into(left_) â‡’ match left_ {
                        injâ‚ nil â‡’ return right
                      â€– injâ‚‚ left_cons â‡’ match right { into(right_) â‡’ match right_ {
                          injâ‚ nil â‡’ return left
                        â€– injâ‚‚ right_cons â‡’ match left_cons {
                            <left_head, left_rest> â‡’ match right_cons {
                              <right_head, right_rest> â‡’
                                let rest_count = nat_pred(total);
                                let left_ge = nat_ge(left_head, right_head);
                                match left_ge {
                                  injâ‚‚ t â‡’ match left_rest {
                                    <left_tail, u> â‡’
                                      let rest = mergesort_merge(rest_count, left_tail, right);
                                      return into(injâ‚‚ <left_head, <rest, <>>>)
                                  }
                                â€– injâ‚ f â‡’ match right_rest {
                                    <right_tail, u> â‡’
                                      let rest = mergesort_merge(rest_count, left, right_tail);
                                      return into(injâ‚‚ <right_head, <rest, <>>>)
                    }}}}}}}}

rec mergesort : âˆ€l : â„• . (list(l) â†’ â†‘âˆƒi : (â„• Ã— (â„• Ã— ğ”¹)) . (slist(i) âˆ§ [((Ï€â‚ Ï€â‚‚ i = l) âˆ§ (Ï€â‚‚ Ï€â‚‚ i = T))]))
              = Î»lst .
                let len = list_len(lst);
                let simple = nat_le(len, nat_1);
                match simple {
                  injâ‚‚ t â‡’ match lst { into(lst_) â‡’ match lst_ {
                    injâ‚ u â‡’ return into(injâ‚ <>)
                  â€– injâ‚‚ lst__ â‡’ match lst__ { <x, xs> â‡’ return into(injâ‚‚ <x, <into(injâ‚ <>), <>>>) }
                  }}
                â€– injâ‚ f â‡’
                    let parts = mergesort_split(lst);
                    match parts {
                      <left, right> â‡’
                        let left_sorted = mergesort(left);
                        let right_sorted = mergesort(right);
                        let sorted = mergesort_merge(len, left_sorted, right_sorted);
                        return sorted
                }}

type comparator = â†“(unat â†’ (unat â†’ â†‘(1 + 1)))

rec quicksort_split : âˆ€l : â„• . (unat â†’ (list(l) â†’ (comparator
                    â†’ â†‘âˆƒs : â„• . ((list(s) Ã— list((l - s))) âˆ§ [(s â‰¤ l)]))))
                    = Î»pivot . Î»lst . Î»cmp .
                    match lst { into(lst_) â‡’ match lst_ {
                        injâ‚ nil â‡’ return <list_nil, list_nil>
                      â€– injâ‚‚ cons â‡’ match cons { <head, tu> â‡’ match tu { <tail, u> â‡’
                          let tail_split = quicksort_split(pivot, tail, cmp);
                          match tail_split { <lt, ge> â‡’
                            let is_lt = cmp(head, pivot);
                            match is_lt {
                              injâ‚ f â‡’ return <lt, into(injâ‚‚ <head, <ge, <>>>)>
                            â€– injâ‚‚ t â‡’ return <into(injâ‚‚ <head, <lt, <>>>), ge>
                      }}}}}}

rec quicksort : âˆ€l : â„• . (list(l) â†’ (comparator â†’ â†‘list(l)))
              = Î»lst . Î»cmp . match lst { into(lst_) â‡’ match lst_ {
                  injâ‚ nil â‡’ return lst
                â€– injâ‚‚ cons â‡’ match cons {
                    <pivot, rest> â‡’ match rest {
                      <tail, u> â‡’
                        let lt_ge = quicksort_split(pivot, tail, cmp);
                        match lt_ge {
                          <lt, ge> â‡’
                            let lt_sorted = quicksort(lt, cmp);
                            let ge_sorted = quicksort(ge, cmp);
                            let result = list_append(lt_sorted, into(injâ‚‚ <pivot, <ge_sorted, <>>>));
                            return result
                }}}}}

def quicksort_asc : âˆ€l : â„• . (list(l) â†’ â†‘list(l))
                  = Î»lst . let sorted = quicksort(lst, {
                      Î»x . Î»y . let lt = nat_lt(x, y);
                      match lt {
                        injâ‚ f â‡’ return injâ‚ <>
                      â€– injâ‚‚ t â‡’ return injâ‚‚ <>
                      }
                    }); return sorted
